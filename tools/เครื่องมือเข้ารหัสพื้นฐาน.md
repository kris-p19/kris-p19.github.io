---
layout: default
title: "‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡∏´‡∏±‡∏™‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô"
description: "Encode / Decode / Hash ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° (Base64, URL, Hex, SHA-256 ‡∏Ø‡∏•‡∏Ø)"
navToolsCryptoBasic: "active"
---

<div class="container py-5">
    <header class="text-center mb-4">
        <h1 class="display-5">‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡∏´‡∏±‡∏™‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô (Basic Crypto Tools)</h1>
        <p class="lead">
            Encode / Decode / Hash ‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÉ‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏î‡∏µ‡∏¢‡∏ß ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö Base64, URL, Hex ‡πÅ‡∏•‡∏∞ SHA-256 / SHA-1 / SHA-512
        </p>
    </header>
    <!--  -->
    <section>
        <div class="row g-3 mb-3 align-items-end">
            <div class="col-md-6">
                <label for="modeSelect" class="form-label">‡πÇ‡∏´‡∏°‡∏î‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô</label>
                <select id="modeSelect" class="form-select">
                    <option value="encode">Encode / ‡∏ñ‡∏≠‡∏î‡∏£‡∏´‡∏±‡∏™‡πÅ‡∏ö‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏î‡πâ</option>
                    <option value="decode">Decode / ‡∏ñ‡∏≠‡∏î‡∏£‡∏´‡∏±‡∏™‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡∏´‡∏±‡∏™</option>
                    <option value="hash">Hash (‡∏ñ‡∏≠‡∏î‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ)</option>
                </select>
            </div>
            <div class="col-md-6">
                <label for="algoSelect" class="form-label">‡∏≠‡∏±‡∏•‡∏Å‡∏≠‡∏£‡∏¥‡∏ó‡∏∂‡∏°</label>
                <select id="algoSelect" class="form-select">
                    <!-- ‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡πÄ‡∏ï‡∏¥‡∏°‡∏î‡πâ‡∏ß‡∏¢ JS ‡∏ï‡∏≤‡∏° mode -->
                </select>
            </div>
        </div>
        <!--  -->
        <div class="row g-3 mb-3">
            <div class="col-md-6">
                <label for="inputText" class="form-label">‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ô‡∏≥‡πÄ‡∏Ç‡πâ‡∏≤ (Input)</label>
                <textarea id="inputText" class="form-control" rows="7"
                    placeholder="‡∏û‡∏¥‡∏°‡∏û‡πå‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡∏´‡∏±‡∏™/‡∏ñ‡∏≠‡∏î‡∏£‡∏´‡∏±‡∏™/‡πÅ‡∏Æ‡∏ä..."></textarea>
            </div>
            <div class="col-md-6">
                <label for="outputText" class="form-label">‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå (Output)</label>
                <textarea id="outputText" class="form-control" rows="7"
                    placeholder="‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏à‡∏∞‡πÅ‡∏™‡∏î‡∏á‡∏ï‡∏£‡∏á‡∏ô‡∏µ‡πâ" readonly></textarea>
            </div>
        </div>
        <!--  -->
        <div class="d-flex flex-wrap gap-2 mb-2">
            <button type="button" id="runBtn" class="btn btn-primary">
                ‚ñ∂ Run
            </button>
            <button type="button" id="swapBtn" class="btn btn-outline-secondary">
                ‚áÑ ‡∏™‡∏•‡∏±‡∏ö Input / Output
            </button>
            <button type="button" id="clearBtn" class="btn btn-outline-secondary">
                üßπ ‡∏•‡πâ‡∏≤‡∏á‡∏Ñ‡πà‡∏≤
            </button>
        </div>
        <!--  -->
        <div id="errorBox" class="text-danger small mb-2"></div>
        <!--  -->
        <div class="alert alert-info small mb-0">
            <strong>‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏:</strong>
            <span class="badge bg-primary-subtle text-primary border border-primary-subtle ms-1">Hash</span>
            (‡πÄ‡∏ä‡πà‡∏ô SHA-256) ‡πÄ‡∏õ‡πá‡∏ô‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ó‡∏≤‡∏á‡πÄ‡∏î‡∏µ‡∏¢‡∏ß <strong>‡∏ñ‡∏≠‡∏î‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ</strong> ‡∏à‡∏£‡∏¥‡∏á ‡πÜ <br>
            ‡∏™‡πà‡∏ß‡∏ô Encode/Decode (‡πÄ‡∏ä‡πà‡∏ô Base64, URL, Hex) ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ñ‡∏≠‡∏î‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏î‡πâ
        </div>
    </section>
</div>

<script>
// ------------------------
// ‡∏≠‡πâ‡∏≤‡∏á‡∏≠‡∏¥‡∏á element
// ------------------------
const modeSelect   = document.getElementById('modeSelect');
const algoSelect   = document.getElementById('algoSelect');
const inputText    = document.getElementById('inputText');
const outputText   = document.getElementById('outputText');
const runBtn       = document.getElementById('runBtn');
const swapBtn      = document.getElementById('swapBtn');
const clearBtn     = document.getElementById('clearBtn');
const errorBox     = document.getElementById('errorBox');

// ------------------------
// ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏≠‡∏±‡∏•‡∏Å‡∏≠‡∏£‡∏¥‡∏ó‡∏∂‡∏°‡∏ï‡∏≤‡∏°‡πÇ‡∏´‡∏°‡∏î
// ------------------------
function setAlgoOptions(mode) {
    algoSelect.innerHTML = '';
    let options = [];

    if (mode === 'encode' || mode === 'decode') {
        options = [
            { value: 'base64', label: 'Base64' },
            { value: 'url',    label: 'URL Encode' },
            { value: 'hex',    label: 'Hex' }
        ];
    } else if (mode === 'hash') {
        options = [
            { value: 'sha-256', label: 'SHA-256 (‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥)' },
            { value: 'sha-1',   label: 'SHA-1 (‡πÄ‡∏Å‡πà‡∏≤)' },
            { value: 'sha-512', label: 'SHA-512' }
        ];
    }

    options.forEach(opt => {
        const o = document.createElement('option');
        o.value = opt.value;
        o.textContent = opt.label;
        algoSelect.appendChild(o);
    });
}

// initial
setAlgoOptions(modeSelect.value);

modeSelect.addEventListener('change', () => {
    setAlgoOptions(modeSelect.value);
    errorBox.textContent = '';
    outputText.value = '';
});

// ------------------------
// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô Encode/Decode Base64 (‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö UTF-8)
// ------------------------
function utf8ToBase64(str) {
    const encoder = new TextEncoder();
    const bytes = encoder.encode(str);
    let binary = '';
    for (const b of bytes) {
        binary += String.fromCharCode(b);
    }
    return btoa(binary);
}

function base64ToUtf8(b64) {
    const binary = atob(b64);
    const bytes = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i++) {
        bytes[i] = binary.charCodeAt(i);
    }
    const decoder = new TextDecoder();
    return decoder.decode(bytes);
}

// ------------------------
// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô Hex
// ------------------------
function toHex(str) {
    const encoder = new TextEncoder();
    const bytes = encoder.encode(str);
    return Array.from(bytes)
        .map(b => b.toString(16).padStart(2, '0'))
        .join('');
}

function fromHex(hex) {
    if (!/^[0-9a-fA-F]*$/.test(hex) || hex.length % 2 !== 0) {
        throw new Error('‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö Hex ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á');
    }
    const bytes = new Uint8Array(hex.length / 2);
    for (let i = 0; i < hex.length; i += 2) {
        bytes[i / 2] = parseInt(hex.slice(i, i + 2), 16);
    }
    const decoder = new TextDecoder();
    return decoder.decode(bytes);
}

// ------------------------
// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô Hash (‡πÉ‡∏ä‡πâ Web Crypto)
// ------------------------
async function hashDigest(algo, message) {
    let name;
    switch (algo) {
        case 'sha-256': name = 'SHA-256'; break;
        case 'sha-1':   name = 'SHA-1';   break;
        case 'sha-512': name = 'SHA-512'; break;
        default: throw new Error('‡πÑ‡∏°‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏≠‡∏±‡∏•‡∏Å‡∏≠‡∏£‡∏¥‡∏ó‡∏∂‡∏°‡∏ô‡∏µ‡πâ');
    }

    const encoder = new TextEncoder();
    const data = encoder.encode(message);
    const buf = await crypto.subtle.digest(name, data);
    const bytes = new Uint8Array(buf);
    return Array.from(bytes)
        .map(b => b.toString(16).padStart(2, '0'))
        .join('');
}

// ------------------------
// ‡∏õ‡∏∏‡πà‡∏° Run
// ------------------------
runBtn.addEventListener('click', async () => {
    errorBox.textContent = '';
    outputText.value = '';

    const mode = modeSelect.value;
    const algo = algoSelect.value;
    const input = inputText.value ?? '';

    try {
        if (!input) {
            errorBox.textContent = '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Input ‡∏Å‡πà‡∏≠‡∏ô';
            return;
        }

        if (mode === 'encode') {
            if (algo === 'base64') {
                outputText.value = utf8ToBase64(input);
            } else if (algo === 'url') {
                outputText.value = encodeURIComponent(input);
            } else if (algo === 'hex') {
                outputText.value = toHex(input);
            }
        } else if (mode === 'decode') {
            if (algo === 'base64') {
                outputText.value = base64ToUtf8(input);
            } else if (algo === 'url') {
                outputText.value = decodeURIComponent(input);
            } else if (algo === 'hex') {
                outputText.value = fromHex(input);
            }
        } else if (mode === 'hash') {
            outputText.value = await hashDigest(algo, input);
        }
    } catch (e) {
        console.error(e);
        errorBox.textContent = '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: ' + e.message;
    }
});

// ------------------------
// ‡∏õ‡∏∏‡πà‡∏°‡∏™‡∏•‡∏±‡∏ö‡∏Ñ‡πà‡∏≤ / ‡∏•‡πâ‡∏≤‡∏á‡∏Ñ‡πà‡∏≤
// ------------------------
swapBtn.addEventListener('click', () => {
    const tmp = inputText.value;
    inputText.value  = outputText.value;
    outputText.value = tmp;
    errorBox.textContent = '';
});

clearBtn.addEventListener('click', () => {
    inputText.value  = '';
    outputText.value = '';
    errorBox.textContent = '';
});
</script>